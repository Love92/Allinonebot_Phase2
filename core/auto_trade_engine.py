# ----------------------- core/auto_trade_engine.py -----------------------
from __future__ import annotations

import os
import asyncio
from dataclasses import dataclass
from typing import Optional, Dict, Any, List, Tuple
from datetime import datetime, timedelta, timezone

# ========= Imports ƒë·ªìng b·ªô v·ªõi /report =========
# L·∫•y K·∫æT QU·∫¢ CHU·∫®N H4/M30/Moon t·ª´ strategy.signal_generator.evaluate_signal()
try:
    from strategy.signal_generator import evaluate_signal  # tr·∫£ v·ªÅ dict: ok, skip, signal, confidence, text, frames
except Exception:
    # fallback n·∫øu c·∫•u tr√∫c d·ª± √°n kh√°c
    from signal_generator import evaluate_signal  # type: ignore

# Moon/tide helpers (ƒë·ªÉ log th√™m late-window, TP-by-time)
try:
    from data.moon_tide import get_tide_events
except Exception:
    get_tide_events = None  # type: ignore

# Tham s·ªë c·ª≠a s·ªï th·ªßy tri·ªÅu m·∫∑c ƒë·ªãnh (c√≥ th·ªÉ ƒë·ªïi qua /tidewindow)
try:
    from config.settings import TIDE_WINDOW_HOURS
except Exception:
    TIDE_WINDOW_HOURS = float(os.getenv("TIDE_WINDOW_HOURS", "2.5"))

# M5 gate: v·∫´n gi·ªØ ƒë·ªÉ ki·ªÉm so√°t cu·ªëi c√πng n·∫øu c·∫ßn
try:
    from strategy.m5_strategy import m5_entry_check
except Exception:
    m5_entry_check = None  # type: ignore
    
# [ADD] Hub + formatter th·ªëng nh·∫•t
try:
    from core.trade_executor import execute_order_flow
except Exception:
    from trade_executor import execute_order_flow  # type: ignore

try:
    from tg.formatter import render_executed_boardcard, render_signal_preview
except Exception:
    # fallback n·∫øu d·ª± √°n ch∆∞a c√≥ ƒë·ªß 2 h√†m (kh√¥ng crash)
    def render_executed_boardcard(**kw):  # type: ignore
        ids = kw.get("entry_ids") or []
        ids_line = " | ".join([str(x) for x in ids]) if ids else "‚Äî"
        return (
            "ü§ñ **EXECUTED**\n"
            f"(Mode: {kw.get('origin','AUTO')}) | {kw.get('symbol','?')} **{kw.get('side','?')}**\n"
            f"üÜî Entry ID(s): {ids_line}"
        )
    def render_signal_preview(*args, **kwargs):  # type: ignore
        return ""
   
    

# Th·ª±c thi l·ªánh (n·∫øu c√≥ k·∫øt n·ªëi s√†n)
ExchangeClient = calc_qty = auto_sl_by_leverage = None
for path in ("core.trade_executor", "trade_executor"):
    try:
        mod = __import__(path, fromlist=["ExchangeClient", "calc_qty", "auto_sl_by_leverage"])
        ExchangeClient = getattr(mod, "ExchangeClient", None)
        calc_qty = getattr(mod, "calc_qty", None)
        auto_sl_by_leverage = getattr(mod, "auto_sl_by_leverage", None)
        if ExchangeClient and calc_qty and auto_sl_by_leverage:
            break
    except Exception:
        continue

# ========= Timezone =========
try:
    import pytz
    VN_TZ = pytz.timezone("Asia/Ho_Chi_Minh")
    JST   = pytz.timezone("Asia/Tokyo")
except Exception:
    VN_TZ = timezone(timedelta(hours=7))  # fallback
    JST   = timezone(timedelta(hours=9))

def now_vn() -> datetime:
    try:
        return datetime.now(VN_TZ)
    except Exception:
        return datetime.utcnow() + timedelta(hours=7)

# ========= Helpers chung =========
def _floor_5m_epoch(ts: int) -> int:
    return ts // 300

def _one_line(tag: str, reason: str, now: datetime, extra: str = "") -> str:
    t = now.strftime("%Y-%m-%d %H:%M:%S")
    return f"[{tag}] {t} | {reason} | {extra}".strip()

async def _debug_send(app, uid: int, text: str) -> None:
    try:
        await app.bot.send_message(chat_id=uid, text=text)
    except Exception:
        pass

# [ADD] Chu·∫©n ho√° side v·ªÅ 'buy'/'sell' cho an to√†n (d√πng n·∫øu c·∫ßn ·ªü n∆°i kh√°c)
def _norm_side_txt(side_long_or_str) -> str:
    if isinstance(side_long_or_str, bool):
        return "buy" if side_long_or_str else "sell"
    s = str(side_long_or_str).strip().upper()
    if s in ("LONG", "BUY"):
        return "buy"
    if s in ("SHORT", "SELL"):
        return "sell"
    raise ValueError(f"Invalid side: {side_long_or_str}")

# ========= [ADD] helper side cho open_market =========
def _side_txt_from_bool(side_long: bool) -> str:
    # True = LONG, False = SHORT
    return "LONG" if bool(side_long) else "SHORT"
# ========= [/ADD] ====================================

# ========= [ADD] Broadcast helpers (ƒë·ªìng b·ªô format v·ªõi /order) =========
import html as _html
from typing import cast
try:
    from telegram import Bot as _TGBot  # python-telegram-bot (async)
except Exception:
    _TGBot = None  # type: ignore

def _esc(s: object) -> str:
    try:
        return _html.escape(str(s or ""), quote=False)
    except Exception:
        return str(s)

_TELEGRAM_BROADCAST_BOT_TOKEN = (os.getenv("TELEGRAM_BROADCAST_BOT_TOKEN") or "").strip()
_TELEGRAM_BROADCAST_CHAT_ID   = (os.getenv("TELEGRAM_BROADCAST_CHAT_ID") or "").strip()
__bcast_bot = None
if _TGBot and _TELEGRAM_BROADCAST_BOT_TOKEN:
    try:
        __bcast_bot = _TGBot(token=_TELEGRAM_BROADCAST_BOT_TOKEN)
    except Exception:
        __bcast_bot = None

async def _broadcast_html(text: str) -> None:
    """G·ª≠i HTML v√†o broadcast group. Im l·∫∑ng n·∫øu thi·∫øu token/chat id."""
    if not (__bcast_bot and _TELEGRAM_BROADCAST_CHAT_ID):
        return
    try:
        await cast(_TGBot, __bcast_bot).send_message(
            chat_id=int(_TELEGRAM_BROADCAST_CHAT_ID),
            text=text,
            parse_mode="HTML",
            disable_web_page_preview=True,
        )
    except Exception:
        pass

# ================== Broadcast t√≠n hi·ªáu  ==================
def _fmt_exec_broadcast(
    *, pair: str, side: str, acc_name: str, ex_id: str,
    lev=None, risk=None, qty=None, entry_spot=None,
    sl: float | None = None, tp: float | None = None,
    tide_label: str | None = None, mode_label: str = "AUTO",
    entry_ids: list[str] | None = None, tp_time=None,
) -> str:
    """
    HTML cho broadcast group ‚Äî format gi·ªëng /order_cmd().
    - C√°c field risk/lev/qty/entry_spot c√≥ th·ªÉ None -> s·∫Ω t·ª± ·∫©n.
    - entry_ids & tp_time l√† t√πy ch·ªçn (n·∫øu c√≥ s·∫Ω in th√™m).
    """
    import html as _html
    def _esc(x):
        try: return _html.escape("" if x is None else str(x), quote=False)
        except: return str(x)

    lines: list[str] = []
    lines.append(f"üöÄ <b>EXECUTED</b> | <b>{_esc(pair)}</b> <b>{_esc(str(side).upper())}</b>")
    lines.append(f"‚Ä¢ Mode: {mode_label}")
    lines.append(f"‚Ä¢ Account: {_esc(acc_name)} ({_esc(ex_id)})")

    # Risk | Lev
    risk_part = f"Risk {float(risk):.1f}%" if isinstance(risk, (int, float)) else ""
    lev_part  = f"Lev x{int(lev)}"         if isinstance(lev,  (int, float)) else ""
    if risk_part or lev_part:
        joiner = " | " if (risk_part and lev_part) else ""
        lines.append(f"‚Ä¢ {risk_part}{joiner}{lev_part}".strip(" |"))

    # Entry(SPOT) | Qty
    entry_part = f"Entry(SPOT)‚âà{float(entry_spot):.2f}" if isinstance(entry_spot, (int, float)) else ""
    qty_part   = f"Qty={float(qty):.6f}"                 if isinstance(qty,        (int, float)) else ""
    if entry_part or qty_part:
        joiner2 = " | " if (entry_part and qty_part) else ""
        lines.append(f"‚Ä¢ {entry_part}{joiner2}{qty_part}".strip(" |"))
    else:
        lines.append("‚Ä¢ Entry: ‚Äî")

    # SL / TP
    lines.append(f"‚Ä¢ SL={float(sl):.2f}" if isinstance(sl,(int,float)) else "‚Ä¢ SL=‚Äî")
    lines.append(f"‚Ä¢ TP={float(tp):.2f}" if isinstance(tp,(int,float)) else "‚Ä¢ TP=‚Äî")

    # TP-by-time (n·∫øu c√≥)
    try:
        if tp_time is not None:
            dt = tp_time
            try:
                from utils.time_utils import VN_TZ  # n·∫øu c√≥
                if getattr(dt, "tzinfo", None) is None:
                    dt = VN_TZ.localize(dt)
                else:
                    dt = dt.astimezone(VN_TZ)
            except Exception:
                pass
            # dt c√≥ th·ªÉ l√† datetime ho·∫∑c string
            timestr = dt.strftime('%Y-%m-%d %H:%M:%S') if hasattr(dt, "strftime") else str(dt)
            lines.append(f"‚Ä¢ TP-by-time: {timestr}")
    except Exception:
        pass

    # Tide
    if tide_label:
        lines.append(f"‚Ä¢ Tide: {_esc(tide_label)}")

    # Entry IDs (n·∫øu c√≥)
    if entry_ids:
        try:
            ids_str = ", ".join(str(x) for x in entry_ids if x)
            if ids_str:
                lines.append(f"‚Ä¢ Entry ID(s): {_esc(ids_str)}")
        except Exception:
            pass

    return "\n".join(lines)

    

def _binance_spot_entry(pair: str) -> float:
    """L·∫•y gi√° hi·ªÉn th·ªã SPOT (Binance) ƒë·ªÉ boardcard. Kh√¥ng d√πng cho kh·ªõp l·ªánh."""
    try:
        from data.market_data import get_klines
        sym = pair.replace("/", "").replace(":USDT", "")
        df = get_klines(symbol=sym, interval="1m", limit=2)
        if df is not None and len(df) > 0:
            return float(df.iloc[-1]["close"])
    except Exception:
        pass
    return 0.0
# ========= [/ADD] ========================================================

# ========= ENV & runtime knobs (c√≥ th·ªÉ ƒë·ªïi b·∫±ng /setenv ho·∫∑c preset) =========
def _env_bool(key: str, default: str = "false") -> bool:
    return (os.getenv(key, default) or "").strip().lower() in ("1", "true", "yes", "on", "y")

M5_MAX_DELAY_SEC        = int(float(os.getenv("M5_MAX_DELAY_SEC", "60")))
SCHEDULER_TICK_SEC      = int(float(os.getenv("SCHEDULER_TICK_SEC", "2")))
MAX_TRADES_PER_WINDOW   = int(float(os.getenv("MAX_TRADES_PER_WINDOW", "2")))

ENTRY_LATE_ONLY         = _env_bool("ENTRY_LATE_ONLY", "false")
ENTRY_LATE_FROM_HRS     = float(os.getenv("ENTRY_LATE_FROM_HRS", "1.0"))
ENTRY_LATE_TO_HRS       = float(os.getenv("ENTRY_LATE_TO_HRS", "2.5"))

AUTO_DEBUG              = _env_bool("AUTO_DEBUG", "true")
AUTO_DEBUG_VERBOSE      = _env_bool("AUTO_DEBUG_VERBOSE", "false")
AUTO_DEBUG_ONLY_WHEN_SKIP = _env_bool("AUTO_DEBUG_ONLY_WHEN_SKIP", "false")
AUTO_DEBUG_CHAT_ID      = os.getenv("AUTO_DEBUG_CHAT_ID", "").strip()

# Rule: M5 bu·ªôc tr√πng h∆∞·ªõng v·ªõi M30 (anh c√≥ th·ªÉ /setenv ENFORCE_M5_MATCH_M30 false ƒë·ªÉ t·∫Øt)
ENFORCE_M5_MATCH_M30 = _env_bool("ENFORCE_M5_MATCH_M30", "true")

# --- Defaults cho c√°c guard b·ªï sung (ƒë·ªÉ _apply_runtime_env c√≥ gi√° tr·ªã ban ƒë·∫ßu) ---
M30_FLIP_GUARD = False              # y√™u c·∫ßu M30 kh√¥ng flip h∆∞·ªõng qu√° nhanh
M30_STABLE_MIN_SEC = 0              # s·ªë gi√¢y t·ªëi thi·ªÉu M30 ph·∫£i ·ªïn ƒë·ªãnh
M30_NEED_CONSEC_N = 1               # s·ªë n·∫øn li√™n ti·∫øp c·∫ßn tho·∫£ ƒëi·ªÅu ki·ªán

M5_MIN_GAP_MIN = 0                  # ph√∫t t·ªëi thi·ªÉu gi·ªØa 2 l·∫ßn v√†o l·ªánh (gap guard)
M5_GAP_SCOPED_TO_WINDOW = True      # gap guard t√≠nh trong 1 c·ª≠a s·ªï tide hay to√†n c·ª•c
ALLOW_SECOND_ENTRY = False          # cho ph√©p v√†o l·ªánh th·ª© 2 trong c√πng c·ª≠a s·ªï
M5_SECOND_ENTRY_MIN_RETRACE_PCT = 0 # % t·ªëi thi·ªÉu retrace ƒë·ªÉ cho l·ªánh th·ª© 2


def _apply_runtime_env(kv: Dict[str, str]) -> None:
    """
    Cho ph√©p /setenv ghi ƒë√® nhanh c√°c ENV trong runtime.
    ƒê·ªìng b·ªô l·∫°i to√†n b·ªô bi·∫øn module ƒë·ªÉ auto-loop √°p d·ª•ng ngay.
    """
    global ENTRY_LATE_ONLY, ENTRY_LATE_FROM_HRS, ENTRY_LATE_TO_HRS
    global AUTO_DEBUG, AUTO_DEBUG_VERBOSE, AUTO_DEBUG_ONLY_WHEN_SKIP, AUTO_DEBUG_CHAT_ID
    global ENFORCE_M5_MATCH_M30, MAX_TRADES_PER_WINDOW
    # Guards / filters m·ªõi:
    global M30_FLIP_GUARD, M30_STABLE_MIN_SEC, M30_NEED_CONSEC_N
    global M5_MIN_GAP_MIN, M5_GAP_SCOPED_TO_WINDOW, ALLOW_SECOND_ENTRY, M5_SECOND_ENTRY_MIN_RETRACE_PCT

    for k, v in kv.items():
        os.environ[k] = str(v)

    try:
        # late-window
        ENTRY_LATE_ONLY         = _env_bool("ENTRY_LATE_ONLY", "true" if ENTRY_LATE_ONLY else "false")
        ENTRY_LATE_FROM_HRS     = float(os.getenv("ENTRY_LATE_FROM_HRS", str(ENTRY_LATE_FROM_HRS)))
        ENTRY_LATE_TO_HRS       = float(os.getenv("ENTRY_LATE_TO_HRS", str(ENTRY_LATE_TO_HRS)))

        # debug
        AUTO_DEBUG              = _env_bool("AUTO_DEBUG", "true" if AUTO_DEBUG else "false")
        AUTO_DEBUG_VERBOSE      = _env_bool("AUTO_DEBUG_VERBOSE", "true" if AUTO_DEBUG_VERBOSE else "false")
        AUTO_DEBUG_ONLY_WHEN_SKIP = _env_bool("AUTO_DEBUG_ONLY_WHEN_SKIP", "true" if AUTO_DEBUG_ONLY_WHEN_SKIP else "false")
        AUTO_DEBUG_CHAT_ID      = os.getenv("AUTO_DEBUG_CHAT_ID", AUTO_DEBUG_CHAT_ID)

        # rules
        ENFORCE_M5_MATCH_M30    = _env_bool("ENFORCE_M5_MATCH_M30", "true" if ENFORCE_M5_MATCH_M30 else "false")

        # quota theo c·ª≠a s·ªï th·ªßy tri·ªÅu
        MAX_TRADES_PER_WINDOW   = int(float(os.getenv("MAX_TRADES_PER_WINDOW",
                                           os.getenv("MAX_ORDERS_PER_TIDE_WINDOW", str(MAX_TRADES_PER_WINDOW)))))

        # guards M30/M5
        M30_FLIP_GUARD          = _env_bool("M30_FLIP_GUARD", "true" if M30_FLIP_GUARD else "false")
        M30_STABLE_MIN_SEC      = int(float(os.getenv("M30_STABLE_MIN_SEC", str(M30_STABLE_MIN_SEC))))
        M30_NEED_CONSEC_N       = int(float(os.getenv("M30_NEED_CONSEC_N", str(M30_NEED_CONSEC_N))))
        M5_MIN_GAP_MIN          = int(float(os.getenv("M5_MIN_GAP_MIN", str(M5_MIN_GAP_MIN))))
        M5_GAP_SCOPED_TO_WINDOW = _env_bool("M5_GAP_SCOPED_TO_WINDOW", "true" if M5_GAP_SCOPED_TO_WINDOW else "false")
        ALLOW_SECOND_ENTRY      = _env_bool("ALLOW_SECOND_ENTRY", "true" if ALLOW_SECOND_ENTRY else "false")
        M5_SECOND_ENTRY_MIN_RETRACE_PCT = float(os.getenv("M5_SECOND_ENTRY_MIN_RETRACE_PCT", str(M5_SECOND_ENTRY_MIN_RETRACE_PCT)))

    except Exception:
        # Kh√¥ng crash auto loop n·∫øu thi·∫øu bi·∫øn ‚Äî ch·ªâ b·ªè qua c·∫≠p nh·∫≠t
        pass


# ========= RISK-SENTINEL (Kho√° AUTO n·∫øu 2 SL li√™n ti·∫øp ·ªü 2 l·∫ßn th·ªßy tri·ªÅu kh√°c nhau trong c√πng ng√†y) =========
AUTO_LOCK_ON_2_SL = (os.getenv("AUTO_LOCK_ON_2_SL", "true").strip().lower() in ("1","true","yes","on","y"))
AUTO_LOCK_NOTIFY  = (os.getenv("AUTO_LOCK_NOTIFY", "true").strip().lower() in ("1","true","yes","on","y"))
_RS_STATE_KEY   = "risk_sentinel"
_RS_STATE_FILE  = "risk_sentinel_state.json"

def _rs_today_str(dt: Optional[datetime] = None) -> str:
    try:
        return (dt or now_vn()).strftime("%Y-%m-%d")
    except Exception:
        return datetime.utcnow().strftime("%Y-%m-%d")

def _rs_load_all(storage) -> Dict[str, Any]:
    if storage:
        data = getattr(storage, "get", lambda k: None)(_RS_STATE_KEY)
        return data if isinstance(data, dict) else {}
    try:
        with open(_RS_STATE_FILE, "r", encoding="utf-8") as f:
            import json as _json
            return _json.load(f) or {}
    except Exception:
        return {}

def _rs_save_all(storage, data: Dict[str, Any]) -> None:
    if storage and hasattr(storage, "set"):
        storage.set(_RS_STATE_KEY, data)
        return
    try:
        with open(_RS_STATE_FILE, "w", encoding="utf-8") as f:
            import json as _json
            _json.dump(data, f, ensure_ascii=False, indent=2)
    except Exception:
        pass

def _rs_get_day(storage, day: str) -> Dict[str, Any]:
    all_data = _rs_load_all(storage)
    return all_data.get(day, {
        "sl_streak": 0,
        "last_result": None,
        "last_window_key": None,
        "locked": False,
        "last_update": now_vn().isoformat() if callable(now_vn) else datetime.utcnow().isoformat(),
    })

def _rs_set_day(storage, day: str, st: Dict[str, Any]) -> None:
    all_data = _rs_load_all(storage)
    st["last_update"] = (now_vn().isoformat() if callable(now_vn) else datetime.utcnow().isoformat())
    all_data[day] = st
    _rs_save_all(storage, all_data)

def _rs_is_locked_today(storage, now: Optional[datetime] = None) -> bool:
    if not AUTO_LOCK_ON_2_SL:
        return False
    d = _rs_today_str(now)
    st = _rs_get_day(storage, d)
    return bool(st.get("locked", False))

def _rs_status_today(storage) -> Dict[str, Any]:
    d = _rs_today_str()
    st = _rs_get_day(storage, d)
    st["day"] = d
    return st

def _rs_reset_today(storage) -> None:
    d = _rs_today_str()
    _rs_set_day(storage, d, {
        "sl_streak": 0, "last_result": None, "last_window_key": None,
        "locked": False, "last_update": now_vn().isoformat() if callable(now_vn) else datetime.utcnow().isoformat()
    })

def _rs_on_trade_close(storage, *, result: str, window_key: Optional[str], when: Optional[datetime] = None) -> bool:
    """
    G·ªçi khi l·ªánh ƒê√ìNG.
    - TƒÉng sl_streak ch·ªâ khi result == 'SL' v√† window_key KH√ÅC v·ªõi SL tr∆∞·ªõc ƒë√≥ (t·ª©c 2 l·∫ßn th·ªßy tri·ªÅu li√™n ti·∫øp).
    - N·∫øu result != 'SL' th√¨ reset streak.
    - Khi sl_streak >= 2 trong c√πng ng√†y => locked=True.
    Tr·∫£ v·ªÅ: locked_today (bool)
    """
    if not AUTO_LOCK_ON_2_SL:
        return False
    d = _rs_today_str(when)
    st = _rs_get_day(storage, d)

    if str(result).upper() == "SL":
        if st.get("last_result") == "SL" and window_key and st.get("last_window_key") and (window_key != st["last_window_key"]):
            st["sl_streak"] = int(st.get("sl_streak", 0)) + 1
        else:
            st["sl_streak"] = 1
    else:
        st["sl_streak"] = 0

    st["last_result"] = str(result).upper()
    if window_key:
        st["last_window_key"] = window_key

    if int(st.get("sl_streak", 0)) >= 2:
        st["locked"] = True

    _rs_set_day(storage, d, st)
    return bool(st.get("locked", False))
# ========= /RISK-SENTINEL =========

# ========= Tide helpers =========
def _nearest_tide_center(now: datetime) -> Optional[datetime]:
    """
    L·∫•y m·ªëc th·ªßy tri·ªÅu g·∫ßn nh·∫•t (High/Low) trong ng√†y ƒë·ªÉ t√≠nh late-window & TP-by-time.
    """
    try:
        if not callable(get_tide_events):
            return None
        lines = get_tide_events(now.date().isoformat()) or []
        cands: List[datetime] = []
        for s in lines:
            parts = str(s).split()
            if len(parts) < 2 or ":" not in parts[1]:
                continue
            hh, mm = parts[1].split(":")
            t = now.replace(hour=int(hh), minute=int(mm), second=0, microsecond=0)
            cands.append(t)
        if not cands:
            return None
        return min(cands, key=lambda t: abs((t - now).total_seconds()))
    except Exception:
        return None

def _current_tp_hours() -> float:
    """
    Th·ªùi gian gi·ªØ l·ªánh t·ªëi ƒëa tr∆∞·ªõc khi TP-by-time (gi·ªù).
    """
    try:
        h = float(os.getenv("TP_TIME_HOURS", "12"))
        return max(0.5, min(48.0, h))
    except Exception:
        return 12.0

# ========= State =========
# L∆∞u text cu·ªëi c√πng ƒë·ªÉ /autolog in ra
_last_decision_text: Dict[int, str] = {}
# Ch·ªëng spam 1 tick trong c√πng slot M5
_last_m5_slot_sent: Dict[int, int] = {}
# ƒê·∫øm s·ªë l·ªánh trong m·ªôt c·ª≠a s·ªï th·ªßy tri·ªÅu (high/low) ƒë·ªÉ gi·ªõi h·∫°n
_user_tide_state: Dict[int, Dict[str, Any]] = {}
# V·ªã th·∫ø ƒëang m·ªü (theo UID) ƒë·ªÉ x·ª≠ l√Ω TP-by-time
_open_pos: Dict[int, Dict[str, Any]] = {}
# [ADD] M·ªëc th·ªùi gian v√†o l·ªánh g·∫ßn nh·∫•t (gap guard)
_LAST_EXEC_TS: Dict[int, float] = {}  # key=uid, val=epoch seconds

def get_last_decision_text(uid: int) -> Optional[str]:
    return _last_decision_text.get(uid)

# Cho ph√©p /setenv ho·∫∑c /preset ghi ƒë√® runtime (n·∫øu c√≥ API)
def set_runtime_env(kv: Dict[str, str]) -> None:
    _apply_runtime_env(kv)

# ========= Quy·∫øt ƒë·ªãnh & v√†o l·ªánh =========
@dataclass
class UserState:
    settings: Any

# ================== AUTO: quy·∫øt ƒë·ªãnh & th·ª±c thi 1 l·∫ßn cho uid ==================
async def decide_once_for_uid(uid: int, app, storage) -> Optional[str]:
    """
    - Tick theo M5 close (ch·∫∑n tr√πng slot)
    - ƒê·ªìng b·ªô H4/M30/Moon v·ªõi /report b·∫±ng evaluate_signal()
    - T√¥n tr·ªçng res['skip'] v√† res['signal'] (NONE/LONG/SHORT)
    - Ki·ªÉm tra late-window theo ENV (ENTRY_LATE_ONLY)
    - (T√πy) M5 gate l·∫ßn cu·ªëi (m5_entry_check) ƒë·ªÉ an to√†n
    - N·∫øu OK: t√≠nh qty, SL/TP, m·ªü l·ªánh (n·∫øu ExchangeClient c√≥ s·∫µn)
    - L∆∞u full text v√†o _last_decision_text ƒë·ªÉ /autolog in l·∫°i
    """
    now = now_vn()

    # 1) L·∫•y user settings
    try:
        st = storage.get_user(uid)
        pair_disp = st.settings.pair or "BTC/USDT"
        symbol = pair_disp.replace("/", "")
        risk_percent = float(getattr(st.settings, "risk_percent", 10.0))
        leverage = int(float(getattr(st.settings, "leverage", 10)))
        mode = str(getattr(st.settings, "mode", "manual")).lower()
        auto_on = (mode == "auto") or bool(getattr(st.settings, "auto_trade_enabled", False))
        balance_usdt = float(getattr(st.settings, "balance_usdt", 100.0))
        tide_window_hours = float(getattr(st.settings, "tide_window_hours", TIDE_WINDOW_HOURS))
    except Exception:
        # Fallback an to√†n
        pair_disp = "BTC/USDT"
        symbol = "BTCUSDT"
        risk_percent = 10.0
        leverage = 10
        mode = "auto"
        auto_on = True
        balance_usdt = 100.0
        tide_window_hours = TIDE_WINDOW_HOURS

    if not auto_on:
        if AUTO_DEBUG and AUTO_DEBUG_VERBOSE:
            await _debug_send(app, uid, _one_line("SKIP", "auto_off", now))
        return None

    # === RISK-SENTINEL: ch·∫∑n auto n·∫øu h√¥m nay ƒë√£ b·ªã LOCK ===
    if _rs_is_locked_today(storage, now):
        if AUTO_LOCK_NOTIFY:
            try:
                chat_id = int(AUTO_DEBUG_CHAT_ID) if AUTO_DEBUG_CHAT_ID.isdigit() else uid
                await app.bot.send_message(chat_id=chat_id, text=f"‚ö†Ô∏è Auto LOCKED h√¥m nay ({_rs_status_today(storage)['day']}). Y√™u c·∫ßu ki·ªÉm tra th·ªß c√¥ng.")
            except Exception:
                pass
        return None

    # 2) Ch·ªâ x·ª≠ l√Ω ngay sau khi ƒë√≥ng n·∫øn M5
    ts = int(now.timestamp())
    slot = _floor_5m_epoch(ts)
    boundary = slot * 300
    delay = ts - boundary
    if not (0 <= delay <= M5_MAX_DELAY_SEC):
        if AUTO_DEBUG and AUTO_DEBUG_VERBOSE:
            await _debug_send(app, uid, _one_line("SKIP", "not_m5_close", now, f"delay={delay}s"))
        return None
    if _last_m5_slot_sent.get(uid) == slot:
        return None
    _last_m5_slot_sent[uid] = slot

    # 3) Evaluate report CHU·∫®N
    try:
        res = evaluate_signal(pair_disp, tide_window_hours=tide_window_hours, balance_usdt=balance_usdt)
    except TypeError:
        res = evaluate_signal(symbol)  # type: ignore
    except Exception as e:
        await _debug_send(app, uid, _one_line("ERR", "evaluate_signal_error", now, str(e)))
        return None

    if not isinstance(res, dict) or not res.get("ok", False):
        reason = (isinstance(res, dict) and (res.get("text") or res.get("reason"))) or "evaluate_signal() failed"
        await _debug_send(app, uid, _one_line("SKIP", "bad_report", now, reason))
        return None

    # 4) R√∫t tr√≠ch th√¥ng tin CHU·∫®N theo /report
    skip_report  = bool(res.get("skip", True))
    desired_side = str(res.get("signal", "NONE")).upper()
    confidence   = int(res.get("confidence", 0))
    text_block   = (res.get("text") or "").strip()
    frames       = res.get("frames", {}) or {}
    h4           = frames.get("H4", {}) or {}
    m30          = frames.get("M30", {}) or {}
    m5f          = frames.get("M5", {}) or {}

    # 5) Late-window theo m·ªëc th·ªßy tri·ªÅu g·∫ßn nh·∫•t
    center = _nearest_tide_center(now)
    tau = None
    if isinstance(center, datetime):
        tau = (now - center).total_seconds() / 3600.0
    in_late = (tau is not None) and (ENTRY_LATE_FROM_HRS <= tau <= ENTRY_LATE_TO_HRS)

    # Guard ENTRY_LATE_ONLY
    if ENTRY_LATE_ONLY and not in_late:
        msg = _one_line("SKIP", "late_only_block", now, f"tau={tau:.2f}h, need {ENTRY_LATE_FROM_HRS}‚Äì{ENTRY_LATE_TO_HRS}h")
        _last_decision_text[uid] = msg + ("\n\n" + text_block if text_block else "")
        if not AUTO_DEBUG_ONLY_WHEN_SKIP:
            await _debug_send(app, uid, msg)
        return msg

    # Quota m·ªói c·ª≠a s·ªï th·ªßy tri·ªÅu
    key_day = now.strftime("%Y-%m-%d")
    key_win = f"{center.strftime('%H:%M') if center else 'NA'}"
    st_user = _user_tide_state.setdefault(uid, {})
    st_day  = st_user.setdefault(key_day, {})
    st_key  = st_day.setdefault(key_win, {"trade_count": 0})
    if int(st_key.get("trade_count", 0)) >= MAX_TRADES_PER_WINDOW:
        msg = _one_line("SKIP", "reach_trade_limit_window", now, f"win={key_win}")
        _last_decision_text[uid] = msg + "\n\n" + text_block
        if not AUTO_DEBUG_ONLY_WHEN_SKIP:
            await _debug_send(app, uid, msg)
        return msg

    # 6) Skip theo /report
    if skip_report:
        msg = _one_line("SKIP", "report_skip", now, text_block.splitlines()[0] if text_block else "")
        _last_decision_text[uid] = msg + "\n\n" + text_block
        if not AUTO_DEBUG_ONLY_WHEN_SKIP:
            await _debug_send(app, uid, msg)
        return msg

    # 7) Kh√¥ng c√≥ t√≠n hi·ªáu
    if desired_side not in ("LONG", "SHORT"):
        msg = _one_line("SKIP", "no_signal", now, f"conf={confidence}")
        _last_decision_text[uid] = msg + "\n\n" + text_block
        if not AUTO_DEBUG_ONLY_WHEN_SKIP:
            await _debug_send(app, uid, msg)
        return msg

    # 8) B·∫Øt bu·ªôc M5 c√πng h∆∞·ªõng v·ªõi M30 (n·∫øu b·∫≠t)
    side_m30 = str(m30.get("side", "NONE")).upper()
    if ENFORCE_M5_MATCH_M30:
        if side_m30 not in ("LONG", "SHORT"):
            msg = _one_line("SKIP", "m30_side_none", now, "M30 kh√¥ng c√≥ h∆∞·ªõng r√µ r√†ng")
            _last_decision_text[uid] = msg + "\n\n" + text_block
            if not AUTO_DEBUG_ONLY_WHEN_SKIP:
                await _debug_send(app, uid, msg)
            return msg
        if desired_side != side_m30:
            msg = _one_line("SKIP", "desired_vs_m30_mismatch", now, f"desired={desired_side} | m30={side_m30}")
            _last_decision_text[uid] = msg + "\n\n" + text_block
            if not AUTO_DEBUG_ONLY_WHEN_SKIP:
                await _debug_send(app, uid, msg)
            return msg

    # 9) (T√πy) Gate M5 l·∫ßn cu·ªëi
    if callable(m5_entry_check):
        gate_side = side_m30 if (ENFORCE_M5_MATCH_M30 and side_m30 in ("LONG", "SHORT")) else desired_side
        ok, reason, m5_meta = m5_entry_check(symbol, gate_side)
        if not ok:
            msg = _one_line("SKIP", "m5_gate_fail", now, f"reason={reason}")
            _last_decision_text[uid] = msg + "\n\n" + text_block
            if not AUTO_DEBUG_ONLY_WHEN_SKIP:
                await _debug_send(app, uid, msg)
            return msg

    # M5 gap guard (n·∫øu c·∫•u h√¨nh)
    try:
        gap_min = int(float(os.getenv("M5_MIN_GAP_MIN", os.getenv("ENTRY_SEQ_WINDOW_MIN", "0"))))
    except Exception:
        gap_min = 0
    if gap_min > 0:
        import time
        now_sec = time.time()
        last = _LAST_EXEC_TS.get(uid)
        if last and (now_sec - last) < gap_min * 60:
            need_m = int(gap_min - (now_sec - last) / 60.0 + 0.999)
            note = _one_line("SKIP", "m5_gap_guard", now, f"need‚â•{gap_min}m, c√≤n‚âà{need_m}m")
            _last_decision_text[uid] = note + ("\n\n" + text_block if text_block else "")
            if AUTO_DEBUG and not AUTO_DEBUG_ONLY_WHEN_SKIP:
                await _debug_send(app, uid, note)
            return note
        from time import time as _now_s
        _LAST_EXEC_TS[uid] = _now_s()

    # 10) Kh·ªõp l·ªánh ‚Äî D√ôNG HUB + FORMATTER TH·ªêNG NH·∫§T (minimal diff)
    opened_real = False
    per_account_logs = []
    exec_board_txt = None  # text boardcard EXECUTED

    # TP-by-time ETA (m·∫∑c ƒë·ªãnh 5.5h n·∫øu kh√¥ng set ENV)
    try:
        tp_hours = float(os.getenv("TP_TIME_HOURS", "5.5"))
    except Exception:
        tp_hours = 5.5
    center = center or now
    tp_eta = center + timedelta(hours=tp_hours)

    # Nh√£n tide hh:mm‚Äìhh:mm ƒë·ªÉ ch√®n v√†o boardcard preview (n·∫øu c·∫ßn)
    try:
        tw_hrs = float(os.getenv("TIDE_WINDOW_HOURS", str(tide_window_hours)))
    except Exception:
        tw_hrs = tide_window_hours
    try:
        start_hhmm = (center - timedelta(hours=tw_hrs/2)).strftime("%H:%M")
        end_hhmm   = (center + timedelta(hours=tw_hrs/2)).strftime("%H:%M")
        tide_label = f"{start_hhmm}‚Äì{end_hhmm}"
    except Exception:
        tide_label = None

    # (1) T√≠nh s∆° b·ªô SL/TP ƒë·ªÉ l∆∞u v√†o pos & cung c·∫•p cho hub (hub v·∫´n c√≥ th·ªÉ t·ª± t√≠nh n·∫øu thi·∫øu)
    try:
        try:
            ref_close = float(m30.get("close") or h4.get("close"))
        except Exception:
            ref_close = 0.0
        if (auto_sl_by_leverage is None) or (ref_close <= 0):
            raise RuntimeError("no auto_sl_by_leverage or bad ref_close")
        sl_price, tp_price = auto_sl_by_leverage(ref_close, desired_side, leverage)
    except Exception:
        sl_price, tp_price = (None, None)

    # (2) Chu·∫©n b·ªã c·∫•u h√¨nh cho hub
    qty_cfg = {"sl": sl_price, "tp": tp_price}
    risk_cfg = {"risk_percent": float(risk_percent), "leverage": int(leverage)}
    accounts_cfg = {"enabled": True}
    meta = {
        "reason": "AUTO_LOOP",
        "score_meta": {"confidence": confidence, "H4": h4.get("score", 0), "M30": m30.get("score", 0)},
        "tide_meta": {"center": center.isoformat() if isinstance(center, datetime) else str(center), "tide_label": tide_label},
        "frames": frames,
    }

    # (3) G·ªåI HUB
    try:
        opened_real, exec_result = await execute_order_flow(
            app, storage,
            symbol=pair_disp,
            side=desired_side,
            qty_cfg=qty_cfg,
            risk_cfg=risk_cfg,
            accounts_cfg=accounts_cfg,
            meta=meta,
            origin="AUTO",
        )
    except Exception as _e_hub:
        opened_real = False
        exec_result = {"error": str(_e_hub), "entry_ids": [], "per_account": {}}

    # (4) Build log per-account (ph·ª•c v·ª• /autolog)
    try:
        pa = exec_result.get("per_account", {}) or {}
        for name, info in pa.items():
            if isinstance(info, dict):
                if info.get("opened"):
                    per_account_logs.append(f"‚Ä¢ {name} | opened | id={info.get('entry_id')}")
                else:
                    per_account_logs.append(f"‚Ä¢ {name} | FAILED: {info.get('error','?')}")
    except Exception:
        pass

    # (5) BROADCAST EXECUTED (format GI·ªêNG /order_cmd)
    if opened_real:
        # (gi·ªØ nguy√™n preview cho n·ªôi b·ªô n·∫øu c·∫ßn)
        try:
            preview_block = render_signal_preview(
                {"signal": desired_side}, frames, {"late": in_late, "tide_label": tide_label},
                {"confidence": confidence},
                {"preset": None},
                {"center": center.isoformat() if isinstance(center, datetime) else str(center)},
                "AUTO",
            )
        except Exception:
            preview_block = ""

        # === Thay broadcast: d√πng _fmt_exec_broadcast gi·ªëng /order_cmd ===
        try:
            side_label = "LONG" if desired_side == "LONG" else "SHORT"
            pair_clean = pair_disp.replace(":USDT","")

            # L·∫•y th√¥ng tin t·ª´ exec_result (n·∫øu hub tr·∫£ v·ªÅ)
            single = (exec_result or {}).get("per_account", {}).get("single", {}) if isinstance(exec_result, dict) else {}
            account_name  = single.get("account_name") or single.get("name") or "auto"
            exchange_name = single.get("exchange_name") or single.get("exchange") or single.get("exid") or "auto"
            qty_print = single.get("qty")
            sl_print  = single.get("sl") if single.get("sl") is not None else sl_price
            tp_print  = single.get("tp") if single.get("tp") is not None else tp_price

            # Entry(SPOT) ƒë·ªÉ hi·ªÉn th·ªã ƒë·∫πp
            try:
                entry_spot = _binance_spot_entry(pair_clean)  # n·∫øu helper c√≥ s·∫µn
            except Exception:
                try:
                    entry_spot = float(m30.get("close") or h4.get("close") or 0.0)
                except Exception:
                    entry_spot = None

            btxt = _fmt_exec_broadcast(
                pair=pair_clean,
                side=side_label,
                acc_name=account_name, ex_id=exchange_name,
                lev=leverage, risk=risk_percent, qty=qty_print, entry_spot=entry_spot,
                sl=sl_print, tp=tp_print,
                tide_label=tide_label, mode_label="AUTO",
                entry_ids=list((exec_result or {}).get("entry_ids") or []),
                tp_time=tp_eta,  # in TP-by-time n·∫øu ƒëang √°p d·ª•ng
            )
            await _broadcast_html(btxt)
        except Exception:
            pass

    # 11) L∆∞u tr·∫°ng th√°i v·ªã th·∫ø ƒë·ªÉ TP-by-time (d√πng tp_eta ·ªü tr√™n)
    try:
        tide_window_key = center.strftime("%Y-%m-%dT%H:%M")
    except Exception:
        tide_window_key = str(center)

    _open_pos[uid] = {
        "pair": pair_disp, "side": desired_side, "qty": None if not opened_real else "live",
        "entry_time": now, "tide_center": center, "tp_deadline": tp_eta, "simulation": (not opened_real),
        "sl_price": (sl_price if 'sl_price' in locals() else None),
        "tide_window_key": tide_window_key,
    }

    # Ch·ªâ tƒÉng trade_count khi opened_real
    if opened_real:
        st_key["trade_count"] = int(st_key.get("trade_count", 0)) + 1
    order_seq = int(st_key.get("trade_count", 0))

    # 12) Build log /autolog
    header = (
        f"ü§ñ AUTO EXECUTE | {pair_disp} {desired_side}\n"
        f"Score H4/M30: {h4.get('score',0)} / {m30.get('score',0)} | Total‚âà{confidence}\n"
        f"rule M5==M30: {'ON' if ENFORCE_M5_MATCH_M30 else 'OFF'} | m30={side_m30}\n"
        f"late_window={'YES' if in_late else 'NO'} | "
        f"TP-by-time: {tp_eta.strftime('%Y-%m-%d %H:%M:%S')}\n"
        f"‚û°Ô∏è EXECUTE {'OK' if opened_real else 'FAIL'} | {'counted' if opened_real else 'not-counted'}\n"
        f"{'\n'.join(per_account_logs) if per_account_logs else ''}\n"
        f"{'üì£ Opened trade #' + str(order_seq) + '/' + str(MAX_TRADES_PER_WINDOW) if opened_real else ''}\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
    )
    final_text = header + (text_block or "(no_report_block)")
    _last_decision_text[uid] = final_text

    # G·ª≠i log ra k√™nh debug
    try:
        chat_id = int(AUTO_DEBUG_CHAT_ID) if AUTO_DEBUG_CHAT_ID.isdigit() else uid
    except Exception:
        chat_id = uid
    try:
        await app.bot.send_message(chat_id=chat_id, text=final_text)
    except Exception:
        pass

    return final_text


# ========= TP-by-time theo m·ªëc th·ªßy tri·ªÅu =========
async def maybe_tp_by_time(uid: int, app, storage) -> Optional[str]:
    if uid not in _open_pos:
        return None

    pos = _open_pos[uid]
    now = now_vn()
    dl = pos.get("tp_deadline")

    # === RISK-SENTINEL: n·∫øu v·ªã th·∫ø ƒë√£ t·ª± ƒë√≥ng tr∆∞·ªõc h·∫°n, ki·ªÉm tra xem ƒë√≥ c√≥ ph·∫£i SL kh√¥ng ===
    # ƒêi·ªÅu ki·ªán: tr∆∞·ªõc h·∫°n TP-by-time nh∆∞ng position ƒë√£ flat (qty=0) -> suy ƒëo√°n ƒë√≥ng do SL ho·∫∑c manual/TP.
    try:
        if callable(ExchangeClient):
            ex = ExchangeClient()
            side_long, qty = await ex.current_position(pos.get("pair","BTC/USDT"))
            if (qty or 0.0) <= 1e-12:
                # V·ªã th·∫ø ƒë√£ h·∫øt. L·∫•y gi√° hi·ªán t·∫°i ƒë·ªÉ suy ƒëo√°n.
                last_price = None
                try:
                    ticker = await ex._io(ex.client.fetch_ticker, pos.get("pair","BTC/USDT"))
                    last_price = float(ticker.get("last") or ticker.get("close") or 0.0)
                except Exception:
                    last_price = None

                result = "MANUAL"
                sl_p = pos.get("sl_price")
                side = str(pos.get("side","")).upper()
                if sl_p and last_price:
                    try:
                        if side == "LONG" and last_price <= float(sl_p) * 1.001:
                            result = "SL"
                        elif side == "SHORT" and last_price >= float(sl_p) * 0.999:
                            result = "SL"
                    except Exception:
                        pass

                locked = _rs_on_trade_close(
                    storage=storage,
                    result=result,
                    window_key=pos.get("tide_window_key"),
                    when=now,
                )
                # d·ªçn tr·∫°ng th√°i
                _open_pos.pop(uid, None)

                # th√¥ng b√°o n·∫øu kho√°
                if locked and AUTO_LOCK_NOTIFY:
                    try:
                        chat_id = int(AUTO_DEBUG_CHAT_ID) if AUTO_DEBUG_CHAT_ID.isdigit() else uid
                        await app.bot.send_message(chat_id=chat_id, text=f"‚õî ƒê√É KH√ìA Auto: 2 SL li√™n ti·∫øp qua 2 l·∫ßn th·ªßy tri·ªÅu. Auto t·∫°m d·ª´ng ƒë·∫øn h·∫øt ng√†y {_rs_status_today(storage)['day']}.")
                    except Exception:
                        pass
                return f"AUTO CLOSE detected ({result})"
    except Exception:
        pass

    # c·∫≠p nh·∫≠t deadline runtime n·∫øu ENV thay ƒë·ªïi
    base = pos.get("tide_center") or pos.get("entry_time") or now
    try:
        if base.tzinfo is None:
            base = base.replace(tzinfo=now.tzinfo)
    except Exception:
        pass
    pos["tp_deadline"] = base + timedelta(hours=_current_tp_hours())
    dl = pos["tp_deadline"]

    if dl and now >= dl:
        order_msg = "(simulation)"
        if callable(ExchangeClient) and not pos.get("simulation"):
            try:
                ex = ExchangeClient()
                res = await ex.close_position(pos["pair"])
                order_msg = getattr(res, "message", str(res))
            except Exception as e:
                order_msg = f"close_err:{e}"

        # d·ªçn state v·ªã th·∫ø
        _open_pos.pop(uid, None)
        msg = f"[TP-BY-TIME] {now.strftime('%Y-%m-%d %H:%M:%S')} | {pos.get('pair')} | {order_msg}"
        try:
            chat_id = int(AUTO_DEBUG_CHAT_ID) if AUTO_DEBUG_CHAT_ID.isdigit() else uid
        except Exception:
            chat_id = uid
        try:
            await app.bot.send_message(chat_id=chat_id, text=msg)
        except Exception:
            pass

        # Risk-sentinel: ƒë√°nh d·∫•u TP ƒë·ªÉ reset streak
        try:
            _ = _rs_on_trade_close(storage, result="TP", window_key=pos.get("tide_window_key"), when=now)
        except Exception:
            pass
        return msg

    return None

# ========= V√≤ng l·∫∑p n·ªÅn =========
async def start_auto_loop(app, storage):
    """
    Worker n·ªÅn: m·ªói SCHEDULER_TICK_SEC, tick qua t·∫•t c·∫£ user ƒë√£ t·ª´ng t∆∞∆°ng t√°c
    """
    uid_env = os.getenv("TELEGRAM_CHAT_ID", "").strip()
    forced_uid = int(uid_env) if uid_env.isdigit() else 0

    while True:
        # L·∫•y danh s√°ch UID t·ª´ storage (ho·∫∑c √©p m·ªôt UID qua env ƒë·ªÉ test)
        uids: List[int] = []
        try:
            data_dict = getattr(storage, "data", {}) or {}
            uids = sorted([int(k) for k in data_dict.keys() if str(k).isdigit()])
        except Exception:
            uids = []
        if forced_uid and forced_uid not in uids:
            uids.append(forced_uid)

        # Tick t·ª´ng user
        for uid in uids:
            try:
                await decide_once_for_uid(uid, app, storage)
                await maybe_tp_by_time(uid, app, storage)
            except Exception as e:
                if AUTO_DEBUG:
                    await _debug_send(app, uid, f"[AUTO][ERR] {now_vn().strftime('%Y-%m-%d %H:%M:%S')} | exception | {e}")
                continue

        await asyncio.sleep(SCHEDULER_TICK_SEC)
# ----------------------- /core/auto_trade_engine.py -----------------------

# (G·ª° b·ªè helper place_order_with_retry d√πng market_with_sl_tp ·ªü b·∫£n c≈©;
# n·∫øu anh v·∫´n mu·ªën retry v·ªõi co-qty, c√≥ th·ªÉ vi·∫øt b·∫£n m·ªõi g·ªçi ex.open_market(...).)
